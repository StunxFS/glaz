// (C) 2021 Glaz Developers. All rights reserved. Use of this source code
// is governed by an MIT license that can be found in the LICENSE file.

const HEADER: str = "// Generated by Glaz. DO NOT MODIFY! ;)

#include <stdint.h>
#include <stddef.h>

typedef int64_t untyped_int;
typedef double untyped_float;

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef float f32;
typedef double f64;

typedef uint8_t bool;
typedef uint32_t rune;

typedef size_t usize;
typedef ptrdiff_t isize;

typedef char* charptr;
typedef void* rawptr;

#define false 0
#define true 1

#define CAST(expr, T) ((T)(expr))
#define ADDR(T, expr) (&((T[]){(expr)}[0]))

#define VTBL_BASE(T) (_##T##_vtbl)
#define VTBL(T, value) (_##T##_vtbl + _##T##__vtbl_index((value)->_typ))

#define BOX_NEW(val, T) std__mem__duplicate(ADDR(T, val), sizeof(T)) // box!()

extern char **environ;

#if defined (__i386__)
	#define _GLAZ__TARGET_IS_XBIT 32
#elif defined (__x86_64__)
	#define _GLAZ__TARGET_IS_XBIT 64
#else
	#error from Glaz: the environment is not 32 or 64-bit
#endif

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
	#define _GLAZ__TARGET_ORDER_IS 1 // BIG
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)
	#define _GLAZ__TARGET_ORDER_IS 2 // LITTLE
#else
	#error from Glaz: unknown architecture endianness
#endif

#if !defined(_GLAZ__TARGET_ORDER_IS)
	#define _GLAZ__TARGET_ORDER_IS 0
#endif

#if !defined(GLAZ_NORETURN)
	#if defined(__TINYC__)
		#include <stdnoreturn.h>
		#define GLAZ_NORETURN noreturn
	#endif

	#if !defined(__TINYC__) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
	   #define GLAZ_NORETURN _Noreturn
	#elif defined(__GNUC__) && __GNUC__ >= 2
	   #define GLAZ_NORETURN __attribute__((noreturn))
	#endif

	#ifndef GLAZ_NORETURN
		#define GLAZ_NORETURN
	#endif
#endif

#if !defined(GLAZ_UNREACHABLE)
	#if defined(__GNUC__) && !defined(__clang__)
		#define V_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)
		#if (V_GCC_VERSION >= 40500L)
			#define GLAZ_UNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#if defined(__clang__) && defined(__has_builtin)
		#if __has_builtin(__builtin_unreachable)
			#define GLAZ_UNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#ifndef GLAZ_UNREACHABLE
		#define GLAZ_UNREACHABLE() do { } while (0)
	#endif
	#if defined(__FreeBSD__) && defined(__TINYC__)
		#define GLAZ_UNREACHABLE() do { } while (0)
	#endif
#endif

";

const G_BREAKPOINT: str = "
// from glib/gbacktrace.h
#if (defined (__i386__) || defined (__x86_64__)) && defined (__GNUC__) && __GNUC__ >= 2
#  define G_BREAKPOINT        { __asm__ __volatile__ (\"int $03\"); }
#elif (defined (_MSC_VER) || defined (__DMC__)) && defined (_M_IX86)
#  define G_BREAKPOINT        { __asm int 3h }
#elif defined (_MSC_VER)
#  define G_BREAKPOINT        { __debugbreak(); }
#elif defined (__alpha__) && !defined(__osf__) && defined (__GNUC__) && __GNUC__ >= 2
#  define G_BREAKPOINT        { __asm__ __volatile__ (\"bpt\"); }
#elif defined (__APPLE__)
#  define G_BREAKPOINT        { __builtin_trap(); }
#else   /* !__i386__ && !__alpha__ */
#  define G_BREAKPOINT        { raise (SIGTRAP); }
#endif  /* __i386__ */

";
